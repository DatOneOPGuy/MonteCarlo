# Cursor Prompt: Recreate Monte Carlo DCF Simulator

Create a production-quality Monte Carlo simulation application for discounted cash flow (DCF) valuation and growth-rate uncertainty modeling, specifically designed for financial analysis like Apple stock valuation. The application must be built as a modular Python package with a Streamlit web interface, following strict type safety, reproducibility, and testing standards. The project structure should be organized as `app/` with subdirectories `core/`, `ui/`, and `tests/`, where `core/` contains all business logic (types, validation, distributions, simulation, analytics, DCF calculations), `ui/` contains Streamlit controls and Plotly visualizations, and `tests/` contains pytest unit tests. All code must use Python 3.10+ type hints with `from __future__ import annotations`, and the project should include a `pyproject.toml` with dependencies for numpy, scipy, plotly, pandas, pydantic, streamlit, and pytest, plus mypy configuration for type checking.

The core functionality must support seven distribution types: Normal (mu, sigma), Lognormal (mu, sigma), Student-t (df, mu, sigma), Triangular (a=min, b=max, c=mode), Uniform (low, high), Beta (alpha, beta), and Custom (CSV upload/paste). All distribution sampling functions should be pure functions that accept a `numpy.random.Generator` (using PCG64 algorithm), size parameter, and validated distribution parameters, returning numpy arrays. Implement a centralized random number generator using `numpy.random.Generator(PCG64(seed))` for complete reproducibility, where all simulation entry points accept `seed: int | None` and `n_sims: int` parameters. The simulation engine must support multi-year growth paths (e.g., Year 1 and Year 2 growth rates) with optional correlation between years via Cholesky decomposition of a user-provided correlation matrix, which must be validated for symmetry and positive definiteness using Pydantic models, with graceful fallback to identity matrix if invalid.

The analytics module must compute comprehensive summary statistics (mean, median, std, skewness, kurtosis), quantiles at 1%, 5%, 25%, 50%, 75%, 95%, 99%, Value at Risk (VaR) and Conditional Value at Risk (CVaR) at user-selectable confidence levels (e.g., 0.05, 0.01), probability of loss and probability of target shortfall, sensitivity analysis via one-at-a-time tornado charts, and partial rank correlation coefficients (PRCC) for parameter sensitivity. The DCF calculation module must implement a complete discounted cash flow valuation function that accepts initial free cash flow (in billions), WACC (weighted average cost of capital), growth rates for Year 1 and Year 2, terminal growth rate or terminal multiple, and number of years, returning present value of cash flows, terminal value, and enterprise value. Additionally, implement an equity value calculation function that converts enterprise value to equity value by adding cash, subtracting debt, and dividing by shares outstanding.

The Streamlit UI must have a left sidebar containing all controls: a toggle for DCF Valuation Mode, scenario selector (Base/Bull/Bear with weights), distribution selectors for Year 1 and Year 2 growth rates (with contextually appearing parameter fields based on distribution type), optional correlation matrix input (with validation), simulation parameters (n_sims, seed, LHS toggle), and export options. The main area should display key performance indicators (KPIs) as metric cards showing mean, median, std, VaR, CVaR, and probability of loss, followed by tabbed visualizations including Distribution (histogram with KDE overlay), ECDF (empirical cumulative distribution function), Fan Chart (for multi-period projections showing percentiles over time), Convergence (showing how statistics stabilize with sample size), Tornado (sensitivity analysis bar chart), and Details (raw data preview table). When DCF mode is enabled, prominently display DCF-specific results including enterprise value statistics, equity value per share (if cash/debt/shares provided), and comparison to market capitalization, plus input visualizations showing the distributions of Year 1 and Year 2 growth rates.

Include Apple-specific presets that set initial FCF to $105.0 billion, WACC to 8.21% (0.0821), terminal growth to 3% (0.03), and configure Year 1 and Year 2 growth rates as triangular distributions with Year 1 having min=-0.05, mode=0.08, max=0.15 and Year 2 having min=-0.03, mode=0.06, max=0.12. When the Apple preset is active, display an info message and show the triangular distribution parameters (min, mode, max) clearly in the sidebar. All user inputs must be validated using Pydantic models that check numeric types, parameter ranges (e.g., Beta alpha/beta > 0, Lognormal sigma > 0, correlation matrix symmetry), and provide clear error messages via `st.warning` or `st.error` with fallback defaults. Implement Streamlit caching using `@st.cache_data` for expensive simulations keyed by parameter hash (computed from configuration dictionary) and seed, and `@st.cache_resource` for any heavy initialization.

The visualization functions must use Plotly exclusively for all charts, with consistent styling, interactive tooltips, and proper axis labels. Implement histogram with KDE overlay using plotly.graph_objects, ECDF using empirical cumulative distribution, fan chart showing multiple percentile bands over time periods, tornado chart as horizontal bar chart sorted by sensitivity magnitude, convergence plot showing how mean/median/std evolve with sample size, and quantile band plot. All plots should be exportable as PNG or SVG. The application must support exporting raw simulation outputs as CSV (with all simulation paths), parameters as JSON (complete configuration), and plots as downloadable files. Display seed and run metadata (timestamp, parameter hash) in a footer section.

For testing, write comprehensive pytest unit tests in `app/tests/` that verify fixed seed determinism (same seed produces identical results), distribution parameter validation (invalid parameters raise appropriate errors), shape and NaN invariants (outputs have correct shape, no NaN values), VaR/CVaR known examples (test against hand-calculated values), and correlation application (correlation matrix correctly transforms independent samples). All tests must use fixed seeds and assert exact reproducibility.

Include comprehensive documentation: a main `app/README.md` with project overview, installation instructions, architecture diagram, feature list, distribution guide, analytics explanation, reproducibility section with example seeds, and export guide. Create an `app/APPLE_PROJECT_GUIDE.md` with step-by-step instructions for using the app for Apple valuation, including how to enable DCF mode, set parameters, interpret results, and use the Apple presets. Create a `app/METHODOLOGY_EXPLANATION.md` that explains why Monte Carlo simulation is appropriate (uncertainty quantification, complex model interactions, decision-making under uncertainty, transparency), why FCF growth rates are the focus (foundation of DCF, highly uncertain for Apple, capture multiple risk factors, Years 1-2 are critical period), and why triangular distributions are used (incorporate expert judgment, capture asymmetric uncertainty, simple yet flexible).

Additionally, create a standalone script `app/mc_dcf_apple.py` that demonstrates a complete Apple DCF valuation workflow: it should set FCF to $105.0 billion, WACC to 8.21%, use triangular distributions for Year 1 and Year 2 growth (with the same parameters as the preset), run 10,000 simulations with a fixed seed, compute enterprise value distribution, calculate equity value (assuming Apple's cash, debt, and shares outstanding), and save results to CSV and generate a plot of the enterprise value distribution saved as PNG. The script should include comprehensive docstrings, type hints, and print summary statistics.

Ensure all files have proper imports, error handling with try-except blocks that show user-friendly messages, logging for debug records (no secrets), and that the Streamlit app handles edge cases gracefully (empty inputs, invalid distributions, missing data). The application should be fast and responsive, using vectorized NumPy operations throughout and avoiding Python loops in hot paths. When running `streamlit run app/streamlit_app.py`, the app must start without errors, display correctly in the browser, and allow users to configure simulations, run them, view results, and export data seamlessly.

